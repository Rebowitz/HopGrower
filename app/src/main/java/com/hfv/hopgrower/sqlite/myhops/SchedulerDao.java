package com.hfv.hopgrower.sqlite.myhops;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteStatement;import de.greenrobot.dao.AbstractDao;import de.greenrobot.dao.Property;import de.greenrobot.dao.internal.DaoConfig;// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT./** * DAO for table SCHEDULER. */public class SchedulerDao extends AbstractDao<Scheduler, Long> {    public static final String TABLENAME = "SCHEDULER";    /**     * Properties of entity Scheduler.<br/>     * Can be used for QueryBuilder and for referencing column names.     */    public static class Properties {        public final static Property Id = new Property(0, Long.class, "id", true, "_id");        public final static Property MhID = new Property(1, long.class, "mhID", false, "MYHOPS_ID");        public final static Property StartDate = new Property(2, java.util.Date.class, "StartDate", false, "START_DATE");        public final static Property EndDate = new Property(3, java.util.Date.class, "EndDate", false, "END_DATE");        public final static Property Location = new Property(4, String.class, "Location", false, "LOCATION");        public final static Property Event = new Property(5, String.class, "Event", false, "EVENT");        public final static Property EventOther = new Property(6, String.class, "EventOther", false, "EVENT_OTHER");        public final static Property Description = new Property(7, String.class, "Description", false, "DESCRIPTION");        public final static Property Recurring = new Property(8, Integer.class, "Recurring", false, "RECURRING");        public final static Property Interval = new Property(9, Integer.class, "Interval", false, "INTERVAL");        public final static Property RecurrRec = new Property(10, Integer.class, "RecurrRec", false, "RECURR_REC");    }    public SchedulerDao(DaoConfig config) {        super(config);    }    public SchedulerDao(DaoConfig config, MHDaoSession daoSession) {        super(config, daoSession);    }    /**     * Creates the underlying database table.     */    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {        String constraint = ifNotExists ? "IF NOT EXISTS " : "";        db.execSQL("CREATE TABLE " + constraint + "'SCHEDULER' (" + //                "'_id' INTEGER PRIMARY KEY ," + // 0: id                "'MYHOPS_ID' INTEGER NOT NULL ," + // 1: mhID                "'START_DATE' INTEGER," + // 2: StartDate                "'END_DATE' INTEGER," + // 3: EndDate                "'LOCATION' TEXT," + // 4: Location                "'EVENT' TEXT," + // 5: Event                "'EVENT_OTHER' TEXT," + // 6: EventOther                "'DESCRIPTION' TEXT," + // 7: Description                "'RECURRING' INTEGER," + // 8: Recurring                "'INTERVAL' INTEGER," + // 9: Interval                "'RECURR_REC' INTEGER);"); // 10: RecurrRec    }    /**     * Drops the underlying database table.     */    public static void dropTable(SQLiteDatabase db, boolean ifExists) {        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SCHEDULER'";        db.execSQL(sql);    }    /**     * @inheritdoc     */    @Override    protected void bindValues(SQLiteStatement stmt, Scheduler entity) {        stmt.clearBindings();        Long id = entity.getId();        if (id != null) {            stmt.bindLong(1, id);        }        stmt.bindLong(2, entity.getMhID());        java.util.Date StartDate = entity.getStartDate();        if (StartDate != null) {            stmt.bindLong(3, StartDate.getTime());        }        java.util.Date EndDate = entity.getEndDate();        if (EndDate != null) {            stmt.bindLong(4, EndDate.getTime());        }        String Location = entity.getLocation();        if (Location != null) {            stmt.bindString(5, Location);        }        String Event = entity.getEvent();        if (Event != null) {            stmt.bindString(6, Event);        }        String EventOther = entity.getEventOther();        if (EventOther != null) {            stmt.bindString(7, EventOther);        }        String Description = entity.getDescription();        if (Description != null) {            stmt.bindString(8, Description);        }        Integer Recurring = entity.getRecurring();        if (Recurring != null) {            stmt.bindLong(9, Recurring);        }        Integer Interval = entity.getInterval();        if (Interval != null) {            stmt.bindLong(10, Interval);        }        Integer RecurrRec = entity.getRecurrRec();        if (RecurrRec != null) {            stmt.bindLong(11, RecurrRec);        }    }    /**     * @inheritdoc     */    @Override    public Long readKey(Cursor cursor, int offset) {        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);    }    /**     * @inheritdoc     */    @Override    public Scheduler readEntity(Cursor cursor, int offset) {        Scheduler entity = new Scheduler( //                cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id                cursor.getLong(offset + 1), // mhID                cursor.isNull(offset + 2) ? null : new java.util.Date(cursor.getLong(offset + 2)), // StartDate                cursor.isNull(offset + 3) ? null : new java.util.Date(cursor.getLong(offset + 3)), // EndDate                cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4), // Location                cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5), // Event                cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6), // EventOther                cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7), // Description                cursor.isNull(offset + 8) ? null : cursor.getInt(offset + 8), // Recurring                cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9), // Interval                cursor.isNull(offset + 10) ? null : cursor.getInt(offset + 10) // RecurrRec        );        return entity;    }    /**     * @inheritdoc     */    @Override    public void readEntity(Cursor cursor, Scheduler entity, int offset) {        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));        entity.setMhID(cursor.getLong(offset + 1));        entity.setStartDate(cursor.isNull(offset + 2) ? null : new java.util.Date(cursor.getLong(offset + 2)));        entity.setEndDate(cursor.isNull(offset + 3) ? null : new java.util.Date(cursor.getLong(offset + 3)));        entity.setLocation(cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4));        entity.setEvent(cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5));        entity.setEventOther(cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6));        entity.setDescription(cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7));        entity.setRecurring(cursor.isNull(offset + 8) ? null : cursor.getInt(offset + 8));        entity.setInterval(cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9));        entity.setRecurrRec(cursor.isNull(offset + 10) ? null : cursor.getInt(offset + 10));    }    /**     * @inheritdoc     */    @Override    protected Long updateKeyAfterInsert(Scheduler entity, long rowId) {        entity.setId(rowId);        return rowId;    }    /**     * @inheritdoc     */    @Override    public Long getKey(Scheduler entity) {        if (entity != null) {            return entity.getId();        } else {            return null;        }    }    /**     * @inheritdoc     */    @Override    protected boolean isEntityUpdateable() {        return true;    }    public int getSchedRecCount(long mhID) {        String theId = Long.toString(mhID);        Cursor cursor = db.rawQuery("Select count(*) from SCHEDULER where MYHOPS_ID = ?", new String[]{theId});        cursor.moveToFirst();        int recs = cursor.getInt(0);        return recs;    }}